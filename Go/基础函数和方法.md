## 命令行参数解析
```go
import "flag"
var name strings
var age int
var is bool
flag.StringVar(&name, "name", "张三", "姓名")   //绑定对象，命令行参数名称，默认值，参数说明
flag.IntVar(&age, "age", 18, "年龄")
flag.BoolVar(&married, "married", false, "婚否")
flag.Parse()    //参数解析
```
## 判断语句
```go
if 布尔表达式 {
   /* 在布尔表达式为 true 时执行代码 */
}
```

## 循环语句
For-Range循环：
用于遍历
```go
for key, value := range oldMap {
    newMap[key] = value
}
```

## String操作

### 字符串比较
> 区分大小写:
```go
StringA == StringB
```
> 不区分大小写:
```go
strings.EqualFold(StringA, StringB)
```

## HTTP请求
### POST请求
```go
client := &http.Client{}
req, err := http.NewRequest("POST", url, strings.NewReader(requestdata))
req.Header.Set(key, value) //设置post请求header数据
resp, err := client.Do(req) //发送http请求
resp.StatusCode //响应状态码
defer resp.Body.Close() //关闭io流
body, err := ioutil.ReadAll(resp.Body) //读取响应内容
```
### 使用代理
```go
proxy, err := url.Parse("url")
client := &http.Client{Transport: &http.Transport{
      Proxy: http.ProxyURL(proxy),
   }}
```

##  文件操作
```go
ioutil.ReadFile(filepath)              #读取全部内容

file, err := os.Open("c:/tmp.txt")     #打开文件
defer file.close                       #关闭文件
content ,err := ioutil.ReadAll(file)   #读取全部内容
r := bufio.NewReader(file)             #按字节读取   bufio — 缓存IO
chunks := make([]byte, 0)
buf := make([]byte, 1024)              #每次读取大小
for {
    n, err := r.Read(buf)              #读取内容
    if err != nil && err != io.EOF {
         panic(err)
         break
      }
    if 0 == n {
         break
      }
    chunks = append(chunks, buf[:n]...)
}
```

## 语法糖
### ... 的用法
1. 第一个用法主要是用于函数有多个不定参数的情况，表示为可变参数，可以接受任意个数但相同类型的参数。
```go
func test1(args ...string) {} //可以接受任意个string参数
```
2. 第二个用法是slice可以被打散进行传递。
```go
var strss= []string{"qwr","234","yui"}
var strss2= []string{ "qqq","aaa","zzz","zzz"}
strss=append(strss,strss2...) //strss2的元素被打散一个个append进strss
```

## 时间相关
```go
time.Now()      #获取当前时间
```

## 占位符
fmt.Sprintf("test%d",i)
- %d  int
- %T  对象数据类型


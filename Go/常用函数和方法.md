## 命令行参数解析
```go
import "flag"
var name strings
var age int
var is bool
flag.StringVar(&name, "name", "张三", "姓名")   //绑定对象，命令行参数名称，默认值，参数说明
flag.IntVar(&age, "age", 18, "年龄")
flag.BoolVar(&married, "married", false, "婚否")
flag.Parse()    //参数解析
```

## 线程池
```go
import "github.com/panjf2000/ants/v2"
wg := sync.WaitGroup{}
p,_ := ants.NewPoolWithFunc(10,func(pre interface{})){
    test(pre,"a")
    wg.Done()
}
defer p.Release()       //关闭线程池
for i,_ := range targets{
    wg.add(1)
    _ = p.Invoke(i)
}
wg.Wait()
```
`WaitGroup`对象内部有个计时器， 最初从0 开始.  
他有3个方法 `Add(),Done(),Wait()` 用来控制计数器的数量。 Add(n)把计数器设置成n,Done()每次把计数器-1  
wait()会阻塞代码的运行,直到计数器的值减为0  
⚠️⚠️⚠️
> WaitGroup 对象不是一个引用类型， 在通过函数传值的时候需要使用地址;
注意：值类型包括基本数据类型，int,float,bool,string,以及数组和结构体(struct)。  
注意：指针也是值类型;sync.WaitGroup 对象是值类型，不是一个引用类型。  
值类型变量声明后，不管是否已经赋值，编译器为其分配内存，此时该值存储于栈上。
```go
go testFunc(i, &wg, ch)
func testFunc(index int, wg *sync.WaitGroup, ch chan int) {}
```

`ants.NewPoolWithFunc()`  
创建了一个 goroutine 池,第一个参数是池容量，第二个参数是每次执行任务的函数。调用p.Invoke(pre)的时候，ants池会在其管理的goroutine中  
找出一个空闲的，让他执行函数`test`,并将`i`作为参数传入

## 语法糖
### ... 的用法
1. 第一个用法主要是用于函数有多个不定参数的情况，表示为可变参数，可以接受任意个数但相同类型的参数。
```go
func test1(args ...string) {} //可以接受任意个string参数
```
2. 第二个用法是slice可以被打散进行传递。
```go
var strss= []string{"qwr","234","yui"}
var strss2= []string{ "qqq","aaa","zzz","zzz"}
strss=append(strss,strss2...) //strss2的元素被打散一个个append进strss
```

## String操作
### 字符串比较
> string转int
```go
strconv.Atoi(string)
```
> int转string
```go
strconv.Itoa(int)
```
> string是否包含指定字符
```go
strings.Contains("test", "te")
```
> 区分大小写:
```go
StringA == StringB
```
> 不区分大小写:
```go
strings.EqualFold(StringA, StringB)
```

## 判断语句
```go
if 布尔表达式 {
   /* 在布尔表达式为 true 时执行代码 */
}
```

## 循环语句
For-Range循环：
用于遍历
```go
for key, value := range oldMap {
    newMap[key] = value
}
```

## 时间相关
```go
time.Now()      #获取当前时间
```

## 占位符
fmt.Sprintf("test%d",i)
- %d  int
- %T  对象数据类型
